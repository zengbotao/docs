# 前言

> 2019年4月26日 星期五 9:00

1.  IO：

    a.  概述

        i.  用于数据的传输

        ii. 方向：输入流、输出流；形式：字节流、字符流

        iii. 四个基本流都是抽象类

        iv. 数据的来源/目的地：磁盘、内存、网络、外设

    b.  流中的异常处理

        i.  需要将关流的操作放到finally

        ii. 需要将流对象放在try之外声明并赋值为null，放在try之内进行实际的初始化

        iii. 在关流之前需要判断流对象是否初始化成功

        iv. 在关流之后需要将流对象置为null

        v.  如果有缓冲区，那么在关流之前需要手动进行一次flush

    c.  文件字符流

        i.  FileReader：没有缓冲区，可以单个字符的读取，也可以自定
            > 义缓冲区 - 字符数组

        ii. FileWriter：自带缓冲区，数据是先写到缓冲区中，然后从缓冲区中写到文件中

    d.  缓冲流

        i.  BufferedReader：本身提供了缓冲区，需要从其他的字符输入
            > 流中来获取数据

        ii. BufferedWriter：提供了更大的缓冲区。另外，提供了newLine方法用于换行

    e.  文件字节流

        i.  FileInputStream - 输入，FileOutputStream - 输出

        ii. 没有缓冲区，因此不需要进行flush操作

# IO(2)

> 2019年4月26日 星期五 9:10

一、转换流

1.  是字符和字节之间进行转换的流

2.  转换输出流 - OutputStreamWriter - 将字符流转化为字节流

3.  转换输入流 - InputStreamReader - 将字节流转化为字符流

4.  转换流是字符流

二、系统流/标准流

1.  系统流对应的不是类而是对象

2.  分类

+---------------------------------+------------------------------------+
| 对象                            | > 解释                             |
+=================================+====================================+
| System.in                       | > 标准输入流                       |
+---------------------------------+------------------------------------+
| System.out                      | > 标准输出流                       |
+---------------------------------+------------------------------------+
| System.err                      | > 标准错误流                       |
+---------------------------------+------------------------------------+

3.  系统流都是字节流

4.  系统流在使用的时候不用关闭

5.  练习：利用学习的流来从控制台获取一行数据

三、打印流

1.  PrintStream - 打印字节流，PrintWriter - 打印字符流

2.  只有输出流没有输入流

3.  提供了便捷的打印方法，并且可以便捷的进行换行操作

四、合并流

1.  用于将多个字节流合并成一个字节流的流

2.  SequenceInputStream - 在构建的时候需要将多个要合并的字节流放入一个

Enumeration中来进行

3.  合并流只有输入流没有输出流

五、序列化/反序列化流

1.  序列化：将对象转化为字节数组的过程

2.  反序列化：将字节数组还原回对象的过程

3.  注意问题：

    a.  如果一个对象要想被序列化，那么这个对象对应的类必须实现接口

> Serializable - 这个接口中没有任何的属性和方法，仅仅作为标记使用

b.  被static/transient修饰的属性不会进行序列化

c.  一个类如果允许被序列化，那么这个类中会产生一个版本号 -
    > serialVersionUID。如果这个类中，没有手动指定版本号，那么在编译的时候自动根据当前类中的属性和方法计算一个版本号，也就意味着如果类中的属性产生改变，则会重新计算一个新的版本号。如果手动指定了版本号，那么不再计算版本号了。在对象序列化的时候，版本号会随着对象一起序列化出去，而在反序列化的时候，拿着对象中的版本号和类中的版本号进行比较。如果版本号一致，则允许反序列
    > 化；如果版本号不一致，则抛出InvalidClassException。版本号的意义是为了防止类产生改动导致已经序列化出去的对象无法反序列化回
    > 来。注意版本号必须用static final修饰，本身必须是long类型、

d.  集合允许被整体序列化 - 集合及其中的元素会一起序列化出去

扩展：

根据流的功能：节点流和处理流

节点流：直接从数据源进行数据的读写 - FileWriter

处理流：封装其他的流，来提供增强的功能 - BufferedReader

六、总结

+-------------------+------------------+-----+------------------------+
| > 流              | 类型             | 缓  | 作用                   |
|                   |                  | 冲  |                        |
|                   |                  | 区  |                        |
+===================+==================+=====+========================+
+-------------------+------------------+-----+------------------------+

+-------------------+------------------+-----+------------------------+
| > FileWriter      | 字符流           | 有  | 1.  以                 |
|                   | 、输出流、节点流 |     | 字符形式向文件中写数据 |
|                   |                  |     |                        |
|                   |                  |     | 2.  继承了             |
|                   |                  |     |                        |
|                   |                  |     | > OutputStreamWriter   |
+===================+==================+=====+========================+
| > FileReader      | 字符流           | 无  | 1.  以字               |
|                   | 、输入流、节点流 |     | 符形式从文件中读取数据 |
|                   |                  |     |                        |
|                   |                  |     | 2.  继承了             |
|                   |                  |     |                        |
|                   |                  |     | > InputStreamReader    |
+-------------------+------------------+-----+------------------------+
| > BufferedReader  | 字符流           | 有  | 1.  需要以其他字       |
|                   | 、输入流、处理流 |     | 符输入流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  提供了缓冲区       |
+-------------------+------------------+-----+------------------------+
| > BufferedWriter  | 字符流           | 有  | 1.  需要以其他字       |
|                   | 、输出流、处理流 |     | 符输出流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  提供了更大的缓冲区 |
|                   |                  |     |                        |
|                   |                  |     | 3.  提供了换行操作 -   |
|                   |                  |     |     newLine            |
+-------------------+------------------+-----+------------------------+
| > FileInputStream | 字节流           | 无  | 以字                   |
|                   | 、输入流、节点流 |     | 节形式从文件中读取数据 |
+-------------------+------------------+-----+------------------------+
| >                 | 字节流           | 无  | 以                     |
|  FileOutputStream | 、输出流、节点流 |     | 字节形式向文件中写数据 |
+-------------------+------------------+-----+------------------------+
| > O               | 字符流           | 有  | 1.  需要以其他的字     |
| utputStreamWriter | 、输出流、处理流 |     | 节输出流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  将字符转化为字节   |
+-------------------+------------------+-----+------------------------+
| >                 | 字符流           | 无  | 1.  需要以其他的字     |
| InputStreamReader | 、输入流、处理流 |     | 节输入流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  将字节转化为字符   |
+-------------------+------------------+-----+------------------------+
| > PrintStream     | 字节流、输出流   | 无  | 提供                   |
|                   | 、节点流、处理流 |     | 了便捷的打印和换行操作 |
+-------------------+------------------+-----+------------------------+

+-------------------+------------------+-----+------------------------+
| > PrintWriter     | 字符流、输出流   | 有  | 提供                   |
|                   | 、节点流、处理流 |     | 了便捷的打印和换行操作 |
+===================+==================+=====+========================+
| > Se              | 字节流           | 无  | 1.  在构建的时候需要传 |
| quenceInputStream | 、输入流、处理流 |     | 入一个Enumeration对象  |
|                   |                  |     |                        |
|                   |                  |     | 2.  将多个字节输入     |
|                   |                  |     | 流合并成一个字节输入流 |
+-------------------+------------------+-----+------------------------+
| >                 | 字节流           | 无  | 1.  需要传入其他的字   |
| ObjectInputStream | 、输入流、处理流 |     | 节输入流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  将字节转化为对象   |
+-------------------+------------------+-----+------------------------+
| > O               | 字节流           | 无  | 1.  需要传入其他的字   |
| bjectOutputStream | 、输出流、处理流 |     | 节输出流来构建当前的流 |
|                   |                  |     |                        |
|                   |                  |     | 2.  将对象转化为字节   |
+-------------------+------------------+-----+------------------------+

# RandomAccessFile

> 2019年4月26日 星期五 14:49

1.  支持对文件进行读写的流，可以认为这是一个双向流

2.  在操作文件的时候，将文件看做了一个大型的**字节数组**

3.  在使用的时候需要指定模式：

    a.  r - 只读模式

    b.  rw - 读写模式

    c.  rws -
        > 读写模式，但是要求将每次的操作都得保存到磁盘上，所以这种方式的效率较低

> Properties
>
> 2019年4月26日 星期五 15:31

1.  是一个可以持久化（实际上是一种特殊的序列化，将对象转化为字节数组，当将字节数组存储到磁盘上的时候就称之为持久化）的**映射**

2.  键和值的类型只能是String

3.  Properties对象在序列化的时候只能序列化到properties文件中

4.  properties文件中，注释是使用的#

5.  properties的默认编码是ISO-8859-1，不兼容中文；如果向properties文件中添加中文的时候，这个中文就会自动转化为其对应的utf-16的编码形式

6.  用于序列化的方法是store，用于反序列化的方法是load

7.  在Properties提供了遍历映射的方式：list(PrintStream)

8.  作为配置文件来使用

# 其他

> 2019年4月26日 星期五 16:08

一、断言

1.  根据之前的条件来对后续的结果进行预判

2.  在java中，断言默认是不开启，需要进行手动开启，添加参数-ea

3.  格式：assert 判断条件; 或者 assert 判断条件 : 提示信息;

二、单元测试

1.  在需要测试的方法之上添加注解@Test

2.  三无：

    a.  要求被测试的方法没有参数

    b.  要求被测试的方法没有返回值 \-\-- 返回值类型必须是void

    c.  要求被测试的方法必须是非静态方法

3.  \@Before表示在测试方法之前执行，一般用于进行初始化操作

4.  \@After表示在测试方法之后执行，一般拥有进行资源的销毁和回收

三、JDK1.5的部分特性

自动封箱/拆箱、增强for循环、泛型、静态导包、可变参数、枚举、反射、动态代理、内省、注解\...

> 静态导包

1.  格式： import static 包名.类名.静态方法名;

2.  优点：能够优先加载指定的方法，提高效率

3.  缺点：

    a.  书写比较麻烦

    b.  降低了代码的可读性

    c.  如果在本类中存在方法签名一致的方法，则导包无效

扩展：JDK1.8的部分特性

Lambda表达式、函数式接口、接口中的实体方法、方法的传递、有效常量、

元注解、时间包\...
