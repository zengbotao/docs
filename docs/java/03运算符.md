## 运算符

### 算术运算符

\+ - \* / % ++ \--

注意问题：

1.  byte/short/char在运算的时候会自动提升为int

2.  整数的运算结果一定是整数

3.  小数的存储和计算都是不精确的

4.  /0

5.  %的计算结果的符号和左边数字的符号有关

6.  ++/\--，如果在变量之前，要求是先自增，然后取出自增之后的值运算。如果是在变量之后，是先取出值参与运算，然后再自增

7.  byte/short/char都可以参与++/\--运算，并且结果类型不会发生改变。底层在运算的时候依然是将byte/short/char提升为int，但是最后的结果在底层会自动做一次强转

byte b1 = 3, b2 = 5, b3;

b3 = b1 + b2; \-\-- false \-\-- 因为byte运算会自动提升为int

byte b = 3;

b = b + 5; \-\-- false \-\-- 因为b是byte，依然会提升为int \-\--
b是变量，那么就意味着在编译的时候无法确定b的具体大小，所以就存在运算结果超过范围的问题，因此底层会将运算结果自动提升为int

byte b = 3 + 5; \-\-- true \-\--
3和5都是字面量，所以在编译的时候能确定值得具体大小，就能判断出是否超过byte的取值范围

byte b = 123 + 5; \-\-- false \-\-- 超过范围

### 赋值运算

= += -= \*= /= %= &= \|= \^= \<\<= \>\>= \>\>\>=

int i = 5;

i += 3; \-\-- 实际上是在自己本身基础上加上指定的数字

int i = 10;

i %= 3; -\> i = i % 3;\-\-- i的值是1

注意：在java中，不支持变量的连等定义，但是支持连等赋值

int i = 5;

i += i -= i \*= 3; \-\-- i的值是多少？ -5

i = 5 + (5 - (5 \* 3)); -\> -5

int i = 5;

i += i -= i \*= ++i; -\> -20

### 关系运算符

\> \< \>= \<= == 相等 != 不等

### 逻辑运算符

针对布尔值来进行运算的

& - And - 与 \| - Or - 或 \^ - Xor - 异或 ! - Not - 非 && - 短路与
\|\| - 短路或

**运算规则**

true&true=true true&false=false false&true=false false&false=false

true\|true=true true\|false=true false\|true=true false\|false=false

true\^true=false true\^false=true false\^true=true false\^false=false

!true=false !false=true

&& -
运算规则和&是一样的。如果&&前边的表达式的结果为false，则&&后边的表达式不再运算，整个表达式的结果确定是false

\|\| -
运算规则和\|是一样的。如果\|\|浅表的表达式的结果为true，则\|\|后边的表达式不再运算，整个表达式的结果确定是true

\|\|会短路掉后边的所有的运算，但是&&只短路自己紧跟的表达式

### 位运算符

注意：位运算针对整数的补码进行的运算

& 与 \| 或 \^ 异或 \<\< 左移 \>\> 右移 \>\>\> 无符号右移 \~ 取反

**交换值的方式：**

int x = 7, y = 10;

方式一：追尾法

int temp = x;

x = y;

y = temp;

方式二：加减法

x = x + y;

y = x - y; -\> y = x + y - y; -\> y = x;

x = x - y; -\> x = x + y - x; -\> x = y;

方式三：异或法

x = x \^ y;

y = x \^ y; -\> y = x \^ y \^ y; -\> y = x;

x = x \^ y; -\> x = x \^ y \^ x; -\> x = y;

效率最高的是异或法，但是使用最多的是追尾法。追尾法的适用范围是最广的。

![](media/image3.png){width="5.317361111111111in"
height="2.0506944444444444in"}

\>\>\>：先将数字转化为补码形式，然后按照指定的位数向右移动，高位次空出，无论正负，一律补0。对于正数而言，右移和无符号右移没有差别的

![](media/image4.png){width="5.372222222222222in"
height="0.8840277777777777in"}

### 三元运算符

格式：逻辑值?表达式1:表达式2

执行顺序：先执行逻辑值，如果逻辑值为true，则执行表达式1；反之，则执行表达式2

int i = 3, j = 5;

int max = i \> j ? i : j;

int i = 5;

System.out.println(i % 2 == 1 ? "是奇数" : "是偶数");

三元表达式本身也可以形成嵌套 \-\-- 例子：求三个数的最大值

方式一:

int max = i \> j ? (i \> k ? i : k):(j \> k ? j : k);

方式二：

int max = i \> j ? i : j;

max = max \> k ? max : k;

注意，三元表达式要求表达式1和表达式2的计算结果的类型要一致

double d = a \> b ? 3 : 3.5;

float f = a \> b ? 'a' : 7.5f;

a \> b ? "abc" : 'a'; \-\-- false

String str = "abc";

char c = 'a';

练习：定义一个变量表示分数，输出这个分数所对应的等级 score \>= 80 -\> A
score \>= 60 -\> B score \< 60 -\> C

### 运算符优先级

() ++ \-- \~ ! 算术 \<\< \>\> \>\>\> 关系 逻辑 & \| \^ 三元 赋值

一元\>二元\>三元

## 流程控制

顺序结构：指的是的程序是从左到右从上到下来依次编译运行的

### 分支结构

判断结构

if(逻辑值){

代码块;

}

![](media/image5.png){width="2.3333333333333335in"
height="1.9506944444444445in"}

if(逻辑值){

Code1;

} else {

Code2;

}

![](media/image6.png){width="3.826388888888889in" height="1.45in"}

练习:

1.  输入三个数字，获取最小值

2.  输入一个数字表示年份，输出一年是否是闰年：如果不是百年，则被4整除；如果是百年，则需要被400整除

    if-else-if结构实际上可以被if-else的嵌套来取代，只是if-else-if结构看起来更加清晰

练习：

1.  输入一个数字表示月份，输出月份所表示的季

    3\~5-Spring 6\~8-Summer 9\~11-Autumn 12/1/2-Winter

2.  输入一个数字表示星期，然后输出这个星期所对应的英文

    1-Monday 2-Tuesday 3-Wednesday 4-Thursday 5-Friday 6-Saturday
    7-Sunday
