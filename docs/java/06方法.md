## 前言：

1.  数组：

    1.  用于存储多个数据的容器。要求存储的元素的数据类型要相同，并且数组定义好之后大小是不可变

    2.  下标 \-\-- 元素的编号，从0开始

    3.  定义格式：动态初始化、静态初始化

    4.  数组的内存：数组本身是存储在堆内存中，并且在堆内存中会赋予默认值。数组每次赋值的时候给的都是地址，数组在栈内存中存储的就是地址

    5.  数组的应用：

        1.  数组的遍历 \-\-- 下标+for，增强for循环，Arrays.toString

        2.  获取最值

        3.  元素的排序 \-\-- 冒泡排序，选择排序 -
            > 时间复杂度O(n^2^)，空间复杂度o(1)，Arrays.sort -
            > 底层是基于快速排序和归并排序

        4.  翻转数组 \-\-- 首尾互换

        5.  元素的查找 \-\-- 元素无序 -\> 遍历；元素有序 -\> 二分查找

        6.  元素的复制 \-\-- System.arraycopy

## 二维数组

用于存储一维数组的数组 \-\--
可以将一维数组认为是小盒子，那么二维数组就是存放这些小盒子的大盒子

### 定义格式

**数据类型\[\]\[\] 数组名 = new
数据类型\[二维数组的大小\]\[一维数组的大小\];**

int\[\]\[\] arr = new int\[3\]\[5\]; \-\--
表示定义了一个能存储3个整型一维数组的二维数组，存储的每一个一维数组能存储5个整型元素

arr\[0\] \-\-- 获取到的是一维数组

arr\[0\]\[2\] \-\-- 获取第0位对应的一维数组的下标为2的位置上的元素

**数组类型\[\]\[\] 数组名 = new 数据类型\[二维数组的大小\]\[\];**

int\[\]\[\] arr = new int\[3\]\[\]; \-\--
表示定义了一个能存储3个整型一维数组的二维数组 \-\--
这种定义方式允许存储的一维数组的大小是不一样的

arr\[0\] = new int\[3\]; \-\-- 表示第0位上的一维数组的大小初始化为3

arr\[1\] = new int\[7\]; \-\-- 表示第1位上的一维数组的大小初始化为7

**数据类型\[\]\[\] 数组名 = {{数组1}, {数组2}\...};**

int\[\]\[\] arr = {{2,4,6,1}, {3,6,2}, {5,1,6,3,8}, {7,9,4}, {8}}; \-\--
定义了能包含5个整型一维数组的二维数组，而且每一个一维数组的大小以及元素是给定的

### 内存存储

![](media/image1.png){width="5.3805555555555555in"
height="2.435416666666667in"}

![](media/image2.png){width="5.242361111111111in"
height="2.3645833333333335in"}

练习：杨辉三角

1

1 1

1 2 1

1 3 3 1

1 4 6 4 1

1 5 10 10 5 1

\...

输入一个数字n表示行数，输出对应的前n行

arr\[i\]\[j\] = arr\[i - 1\]\[j\] + arr\[i - 1\]\[j - 1\];

## 方法

将要重复使用的代码进行提取，提取之后的封装形式就叫方法/函数

### 定义格式

修饰符 返回值类型 方法名(参数列表){

方法体;

return 执行结果;

}

定义方法的时候要明确返回值类型，明确是否需要参数

练习：

1.  判断一个数是否是一个质数 \-\-- 明确返回值 \-\--
    boolean，明确是否需要参数

2.  哥德巴赫猜想：任何一个大于6的偶数可以分解成2个质数之和

    18 = 7 + 11

    24 = 7 + 17

    24 = 11 + 13

    输入任意一个数字，输出他的所有分解形式

3.  亲密数：A的所有因子(含1不含本身)之和等于B，并且B的所有因子(含1不含本身)之和等于A，那么A和B就是一对亲密数
    \-\-- 打印3000以内的亲密数 \-\-- 求一个数的所有因子之和

12 - 1 2 3 4 6 \-\-- 16

16 - 1 2 4 8 \-\-- 15 != 12 \-\-- 12和16不是亲密数

### 重载

在同一个类中，出现方法名相同而参数列表不同的方法

参数列表不同，指的是参数个数是否不同，或者是对应位置上的参数类型是否不一致

如果凭借参数不太容易判断是否重载，可以考虑在调用的时候是否会引起调用的混乱

sum(3.5, 6);

sum(3.5f, 6);

sum(double i, int j)

sum(float i, int j)

### 递归

递归的形式是方法在内部调用自己本身，实质上就是在调用方法

练习：输入一个数，求这个数的阶乘 5! = 5 \* 4 \* 3 \*2 \* 1 n!=n\*\...\*1

递归：找第n项和前n-i项的关系

StackOverflowError - 栈溢出错误 -\>
**方法是栈内存中执行的**。每一个方法在执行的时候会占用一块栈内存。递归的特点是不断的调用方法，如果递归层数太深那就意味着调用的方法太多，导致栈内存不够用

### 内存和传值问题

形参 - 形式参数：定义方法的时候写在()内的参数 sum(int i, int j) -
形参两个int类型的整数

实参 - 实际参数：调用方法的时候传入的值 sum(3,5) \-\-- 3，5就是实参

![](media/image3.png){width="4.4375in" height="2.8319444444444444in"}

![](media/image4.png){width="5.236805555555556in"
height="2.459722222222222in"}

![](media/image5.png){width="5.41875in" height="2.4625in"}
