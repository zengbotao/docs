# 前言

> 2019年4月30日 星期二 8:59

1.  网络编程

    a.  网络模型：在现阶段重点关注的是传输层 - UDP/TCP

    b.  IP地址 - IPv4、IPv6；域名；DNS服务器；端口

    c.  UDP:

        i.  特点：基于网络的流；无连接，不可靠，传输速度较快，对数据封包

        ii. 发送端、接收端 - DatagramSocket

    d.  TCP:

        i.  特点：基于网络的流；面向连接，三次握手，可靠，传输速度 较慢

        ii. 客户端 - Socket、服务器端 - ServerSocket

# 反射

> 2019年4月30日 星期二 9:07

一、概述

1.  动态加载类的过程

2.  Class - 代表字节码的类Method - 代表方法的类Field - 代表属性的类

Constructor - 代表构造方法的类Package - 代表包的类Annotation -
代表注解的类

3.  向上造型+反射实现解耦过程

二、获取Class对象

1.  类名.class

2.  对象.getClass()

3.  Class.forName(类的全路径名)

三、产生实例对象

1.  如果这个类中有无参构造，则可以利用Class类中newInstance()来产生实例对象

2.  如果这个类中没有无参构造，则需要先获取构造方法，然后执行构造方法来获取实例对象

四、修饰符

  -----------------------------------------------------------------------
  修饰符                      十进制值              二进制
  --------------------------- --------------------- ---------------------
  public                      1                     00000001

  private                     2                     00000010

  protected                   4                     00000100

  static                      8                     00001000
  -----------------------------------------------------------------------

+---------------------------+--------------------+---------------------+
| final                     | 16                 | > 00010000          |
+===========================+====================+=====================+
| synchronized              | 32                 | > 00100000          |
+---------------------------+--------------------+---------------------+
| volatile                  | 64                 | > 01000000          |
+---------------------------+--------------------+---------------------+
| transient                 | 128                | > 10000000          |
+---------------------------+--------------------+---------------------+
| abstract                  | 1024               |                     |
+---------------------------+--------------------+---------------------+

四、练习

1\. 完成clone方法

# JDK1.5的特性

> 2019年4月30日 星期二 14:01
>
> 一、可变参数

1.  用\...定义可变参数

2.  在使用的时候可以传入任意多个参数，也可以传递同类型数组，也可以
    > 不传参数

3.  可变参数在底层本质上是一个数组，可以通过操作数组的方式来操作可
    > 变参数

4.  可变参数必须定义在参数列表的末尾，而且一个方法中之能定义一个可
    > 变参数

> 二、枚举

1.  适用于取值固定并且能够一一列举的场景：星期、月份、等级\...

2.  用enum关键字来定义枚举

3.  枚举本质上是一个类

4.  枚举中构造方法默认私有而且只能是私有的

5.  枚举常量之间用 , 隔开

6.  在枚举中，枚举常量必须放在枚举的第一行

7.  枚举中的构造方法可以重载，可以提供含参构造

8.  枚举中可以定义其他的属性和方法

9.  枚举中允许定义抽象方法

10. 在Java中，枚举的顶级父类是Enum类

11. switch-case需要提供选项，选项的类型是byte/short/char/int，JDK1.7开始
    支持String，JDK1.5开始支持枚举

> 三、注解
>
> 概述

1.  用@Interface来定义注解

2.  在注解中定义的属性默认是使用static final修饰

3.  在注解中，是以定义方法的形式来定义属性的

4.  属性的类型只能是基本类型、String、Class、其他注解、枚举或者是这个

> 5个类型的一维数组形式

5.  如果注解中只有1个属性，并且这唯一的一个属性的名字为value，那么
    > 在使用该注解的时候可以省略属性名

6.  注解默认是不随着类生成到文档中

> 元注解

1.  修饰/限制注解的注解

2.  四大元注解：

    a.  **\@Target**：限制注解的使用目标 - 限制注解的使用范围

    b.  **\@Retention**：限制注解的生命周期

    c.  \@Documented：限定这个注解随着类生成到文档中

    d.  \@Inhetied：限制子类的

# JDK1.8的特性

> 2019年4月30日 星期二 15:48

一、接口中的默认方法

1.  在JDK1.8之前，接口中只能定义抽象方法；从JDK1.8开始，接口中允许定义实体方法

2.  实体方法必须用default/static修饰

3.  实现类可以继承接口中的默认方法，但是不能继承静态方法

> 二、**Lambda表达式**

1.  Lambda表达式是用于重写接口中的方法

2.  要求使用Lambda表达式的接口中只能有1个抽象方法

3.  格式：(参数列表 ) -\> {方法体}

4.  Lambda表达式不能够进行向上造型

5.  Lambda表达式体现的逻辑的传递 - 函数式编程

三、方法的传递

1.  当Lambda表达式的方法体只有1句，并且是直接操作参数，调用了已有类/已有对象身上的方法，可以利用::进行方法的传递

2.  方法的传递可以认为是一种特殊的Lambda表达式

四、函数式接口

1.  在JDK1.8中，如果接口中只有一个抽象方法，那么可以将这个接口定义为一个函数式接口，用@FunctionalInterface来限定

2.  Runnable/Comparator/FileFilter/FilenameFilter在JDK1.8中都被限定为了函数式接口

3.  在JDK1.8中，新提供了四个函数式接口：

Predicate、Function、Supplier、Consumer

五、Stream - 并行流

1.  是JDK1.8出现的一个新的接口，不是流

2.  针对集合进行操作的并行流

六、时间包

1\. 在JDK1.8中将时间体系进行了新的划分，形成了一个新的包 - java.time
