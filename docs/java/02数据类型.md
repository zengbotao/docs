### 进制

是计数方式。

二进制：满2进1，0-1，需要以0b作为开头标志

八进制：满8进1，0-7，需要以0作为开头标志

十进制：满10进1，0-9，数字默认就是十进制

十六进制：满16进1，0-9，a-f，需要以0x作为开头标志

### 进制转换

十进制转二进制：将这个数字不断的除以2，然后获取余数，然后将获取到的余数进行倒序排列

![](media/image1.png){width="2.5118055555555556in"
height="1.2722222222222221in"}

二进制转十进制：从数字的低位次，按位次乘以2的位次次幂，然后求和

![](media/image2.png){width="5.205555555555556in"
height="0.8180555555555555in"}

十进制转其他进制：除以对应的进制，获取余数倒排

其他进制转十进制：按位次乘以进制的位次次幂，然后求和

二进制转八进制：从低位次开始，每三位划为一组，每一组产生一个八进制数字。如果最高位不足三位，那么补0补齐三位，将转化出来的数字依次排列
\-\-- 3-\>1

八进制转二进制：1-\>3 \-\-- 每一个八进制数字都会对应三位二进制

二进制转十六进制：4-\>1

十六进制转二进制：1-\>4

## 变量

在程序中用于存储数据的容器

变量名本质上就是标识符，符合标识符的命名规则

![](media/image3.png){width="4.664583333333334in"
height="2.0819444444444444in"}

注意问题：

1.  变量必须先定义后使用

2.  变量必须先有值后使用 \-\-- 初始化：就是第一次给变量赋值

3.  变量的使用有范围的

### 扩展-计量单位：

每一个二进制称之为是1位 - bit

字节 - byte - 1byte = 8bit \-\-- 1B = 8b 100Mb = 12.5MB

千字节 - KB 1KB=1024B=2\^10B

兆字节1MB=1024KB

吉比特GB-\>TB-\>PB

## 数据类型

### 基本数据类型

数值型

整数型

> byte - 字节型 - 1个字节 - -2^7^\~2^7^-1 -\> -128\~127 byte b = 125;
>
> short - 短整型 - 2个字节 - -2^15^ \~2^15^-1 short s = 354;
>
> int - 整型 - 4个字节 - -2^31^\~2^31^-1，整数默认为int类型
>
> long - 长整型 - 8个字节 - -2^63^\~2^63^-1 -\>
> -3.4\*10^18^\~3.4\*10^18^ long类型的数字需要以l/L作为后缀标记 long l =
> 530383798L;

浮点型

> float - 单精度 - 4个字节 - -10^38^\~10^38^
> ，float类型的数字需要以f/F作为后缀标记 float f = 4.58f;
>
> double - 双精度 - 8个字节 - -10^308^\~10^308^ ，小数默认是double类型
> double d = 3.265; double类型也可以以d/D作为后缀
>
> double d = 3d;

字符型

char - 字符型 - 2个字节 - 0\~2^16^-1 -\> '\\u0000' - '\\uffff'

char类型默认采用的是utf-16

char c = '+';

char c = 'f';

转义字符：

'\\t' - 制表符 '\\r'-回车 '\\n'-换行

'\\'' - 单引号 '\\"' - 双引号 '\\\\'-反斜杠\\

### 扩展 - 编码表:

将字符映射成数字 \-\-- 编码

ISO-8859-1 - 西欧编码 - 1个字符1个字节

gb2312 \-\-- 国标码 - 1个字符2个字节 \-\-- gbk \-\--
收录了汉字中的常见简体汉字以及部分常见繁体汉字

Unicode编码体系 \-\-- utf-8 \-\-- 1个字符3个字节，
utf-16\-\--1个字符2个字节

其他码表的前256个字符和西欧码表一致，并且任何一张的前256个字符都是只占1个字节

布尔型

boolean - 布尔型 - true/false，用于表示逻辑值 \-\--
boolean类型的大小是根据jdk版本以及操作系统来确定 \-\--
现在一般而言布尔值是占4个字节

boolean b = true;

### 引用数据类型

类 - class, 接口-interface，数据-\[\]

## 数据类型的转换

### 隐式转换/自动类型转换

byte b = 13;

int i = b;

float f = 3.5f;

double d = f;

规律一：小的类型可以自动转化为大的类型 byte -\> short -\> int -\> long

int i = 100;

float f = i;

规律二：整数可以自动转化为小数，但是导致精度产生损失

char c = 'f';

int i = c;

float f = 'c';

规律三：字符可以转化为整数

![](media/image4.png){width="4.748611111111111in"
height="1.9354166666666666in"}

short s = 'a'; \-\-- true

char c = 97; \-\-- true

char c = 'a';

short s = c; \-\-- false \-\-- 字面量和变量的差别 \--
字面量的值在看到之后就能确定，但是变量的值在看到变量名之后不能确定

Java在编译的时候，只是确定范围是否符合而不会去确定具体值。这就意味着，java在编译char
c =
'a'；只会确定一下的值是否在char类型的取值范围内，而并不关心这个值具体是多大。继续往下便宜short
s =
c;确定c是字符，s是short类型，这个时候会判断字符型和短整型的范围是否能够兼容
-\> short不能完全包含char类型的取值，这个时候就会报错

short s = 'a';

char c = s; \-\-- false

### 显式转换/强制类型转换

int i = 100;

byte b = (byte)i;

规律一：大的类型转化为小的类型

double d = 5.88;

int i = (int)d; -\> 5

规律二：小数转化为整数的时候需要进行强制转换，而在转换的时候舍弃所有的小数位

int i = 100;

char c = (char)i;

规律三：将整数转化为字符

### 扩展 - 数字的原反补三码

数字的二进制中，最高位表示的是符号位。如果最高位为0则表示正数；如果最高位为1，则表示负数

计算机在存储数据的时候存的是数据的补码

对于正数而言，原反补三码是一致的

int i = 10;

原码：00000000 00000000 00000000 00001010

反码：00000000 00000000 00000000 00001010

补码：00000000 00000000 00000000 00001010

对于负数而言，计算出来的十进制转化的二进制是原码；反码是在原码的基础上，最高位不变，其余位0\<-\>1；补码是在反码的基础上+1

int i = -10;

原码：10000000 00000000 00000000 00001010

反码：11111111 11111111 11111111 11110101

补码：11111111 11111111 11111111 11110110

规定：将-0所对应的二进制表示为当前类型的最小值

## 运算符

### 算术运算符

\+ - \* / % ++ \--

注意问题：

1.  byte/short/char在运算的时候会自动提升为int

2.  如果是两个整数参与运算，那么结果一定是整数类型

3.  小数运算是不精确的

4.  整数/0 ArithmeticException - 算术异常

    非零小数/0 任意非零数字/0.0 - Infinity

    0.0/0 0.0/0.0 0/0.0-\>NaN

    \% - 取模 - 取余

    14%4=2

    -15%4=-3

    15%-4=3

    根据左边的数字的符号来确定最后的结果符号

    3.8%1.2=0.2

    ++/\-- 自增/自减

    int i = 5;

    i++; -\> 在结果上和i = i + 1;相同-\> i= 6

    ++i; -\> 如果单独使用和i++一样

    int j = ++i;
    先将i的值5取出来，然后自增，i自增为6之后，再复制给j，所以j的值也是6

    int j = i++;
    先将i的值5取出来，因为除了=以外没有别的运算，将i此时的值标记为结果，然后i自增为6，再将刚才标记的结果赋值给j，此时j的值为5

    int i = 5;

    int j = ++i \* 2;
    先将i的值5取出来，然后i自增为6，然后再利用i的值乘以2，所以最后的结果是12，然后将结果赋值给j

    int j = i++ \* 2;
    先将i的值5取出来，有后续乘法运算，所以将取出的值5拿出来参与后续的乘法运算，所以乘法的运算结果是10，这个过程中i依然要做一次自增，自增为6，最后将结果10赋值给j

    int i = 5;

    int j = ++i \* i++; \-\-- i =7, j = 36

    int j = i++ \* ++i; \-\-- i = 7, j = 35

    byte b = 10;

b++; \-\-- 这个运算可以发生，并且计算结果依然为byte \-\--
意味着java在底层运算的时候依然是将byte提升为了int，但是在最后给结果的时候底层自动做了一次强制转换

思考题:

byte b1 = 3;

byte b2 = 5;

byte b3 = b1 + b2;\-\-- false

byte b1 = 3;

b1 = b1 + 5; \-\-- false

byte b = 3 + 5; \-\-- true

如果行，为什么？
