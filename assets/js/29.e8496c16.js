(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{797:function(v,_,a){"use strict";a.r(_);var t=a(20),p=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("权限修饰符：public protected 默认 private")])]),v._v(" "),_("li",[_("p",[v._v("继承：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("继承是对类的抽取")])]),v._v(" "),_("li",[_("p",[v._v("在Java中，支持的是类和类之间的单继承")])]),v._v(" "),_("li",[_("p",[v._v("单继承和多继承的比较：多继承在代码的复用性上要优于单继承；单继承能够更好的避免方法调用的混乱")])]),v._v(" "),_("li",[_("p",[v._v("作用：提高代码的复用性；避免方法的混乱")])])])]),v._v(" "),_("li",[_("p",[v._v("super关键字")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("代表父类对象的引用，可以认为是一个虚拟对象")])]),v._v(" "),_("li",[_("p",[v._v("在子类中通过super调用父类中部分的方法和属性")])]),v._v(" "),_("li",[_("p",[v._v("super语句：如果不指定，在子类的构造方法中会默认添加一个无参的super语句，表示调用父类中对应形式的构造方法；super语句必须放在构造方法的首行")])])])]),v._v(" "),_("li",[_("p",[v._v("方法的重写/覆盖：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("父子类中，存在方法签名一致的非静态方法")])]),v._v(" "),_("li",[_("p",[v._v("两等两小一大")])])])]),v._v(" "),_("li",[_("p",[v._v("多态：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("编译时多态：重载、隐藏")])]),v._v(" "),_("li",[_("p",[v._v("运行时多态：向上造型、方法的重写")])])])]),v._v(" "),_("li",[_("p",[v._v("静态：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("静态变量：随着类的加载而加载到方法区，并且在方法区中初始化。静态变量是先于对象存在，习惯上是通过类名来调用。对象中存储的是静态变量的地址，所以静态变量是被所有对象共享的")])]),v._v(" "),_("li",[_("p",[v._v("静态方法：在类加载的时候加载到方法区，只存储不执行。在被调用的时候到栈内存中执行。静态方法也是先于对象存在。静态方法中不能直接使用本类中的非静态；静态方法允许重载，不允许重写，但是存在隐藏形式")])]),v._v(" "),_("li",[_("p",[v._v("静态代码块：在类加载的时候执行一次")])])])])]),v._v(" "),_("h2",{attrs:{id:"final"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[v._v("#")]),v._v(" final")]),v._v(" "),_("p",[v._v("修饰符，修饰数据，方法，类")]),v._v(" "),_("p",[v._v("常量 - final修饰数据 -\n定义好之后不能变；对于基本类型的常量限制实际值不可变；如果是引用类型的常量，限制的地址不可变，其中的元素或者是属性可以改变\n--- 对于常量属性而言注意它的给值")]),v._v(" "),_("p",[v._v("最终方法 - final修饰方法 - 最终方法不能被重写/隐藏 -\n可以重载，可以被继承")]),v._v(" "),_("p",[v._v("最终类 - final修饰类 - 不能被继承")]),v._v(" "),_("h2",{attrs:{id:"abstract"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[v._v("#")]),v._v(" abstract")]),v._v(" "),_("p",[v._v("如果一个类的所有子类都对这个类中的某个或者某些方法做了重写，那么可以将这个类中的这些方法进行抽取，抽取成抽象方法。抽象方法所在的类必须是抽象类")]),v._v(" "),_("p",[v._v("抽象类不允许实例化")]),v._v(" "),_("p",[v._v("抽象类能否用final修饰？ - 不能")]),v._v(" "),_("p",[v._v("抽象类的构造方法能否私有化？ - 能")]),v._v(" "),_("p",[v._v("抽象方法能否重载？ - 能")]),v._v(" "),_("p",[v._v("抽象方法能否用static/final/private修饰？ - 不能")]),v._v(" "),_("p",[v._v("如果一个抽象方法的修饰符是默认的，那么这个抽象方法所在和类和子类要同包")]),v._v(" "),_("p",[v._v("练习：定义一个类表示形状（Shape），给这个类提供子类：矩形（Rectangle）,正方形(Square)，椭圆形（Ellipse），圆形（Circle）;求这些形状的周长和面积")]),v._v(" "),_("h2",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[v._v("#")]),v._v(" 接口")]),v._v(" "),_("p",[v._v("用interface定义接口，在JDK1.8以前接口中都是抽象方法；从JDK1.8开始，接口中允许定义实体方法")]),v._v(" "),_("p",[v._v("接口不允许创建对象")]),v._v(" "),_("p",[v._v("类通过implements关键字来实现接口，并且在实现的时候要重写接口中所有的抽象方法")]),v._v(" "),_("p",[v._v("在Java中，类和接口之间是多实现 --- 一个类可以实现多个接口 ---\n多实现可能会导致重写方法的时候产生混乱")]),v._v(" "),_("p",[v._v("接口和接口之间也可以继承，并且支持的是多继承 ---\n一个接口可以继承多个接口")]),v._v(" "),_("p",[v._v("接口中的方法默认都是public修饰")]),v._v(" "),_("p",[v._v("在接口中声明的属性默认是用public static final修饰")]),v._v(" "),_("p",[v._v("从JDK1.8开始，允许在接口中定义实体方法，实体方法必须用default/static修饰\n--- 此时多实现类似于多继承")]),v._v(" "),_("p",[v._v("接口的作用：为了作为模板/协议/约束使用")]),v._v(" "),_("h2",{attrs:{id:"内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[v._v("#")]),v._v(" 内部类")]),v._v(" "),_("p",[_("strong",[v._v("方法内部类 - local class")])]),v._v(" "),_("p",[v._v("定义在方法中的类")]),v._v(" "),_("p",[_("strong",[v._v("成员内部类 - member class")])]),v._v(" "),_("p",[v._v("定义在类中的类")]),v._v(" "),_("p",[_("strong",[v._v("静态内部类")])]),v._v(" "),_("p",[v._v("用static修饰的内部类")]),v._v(" "),_("p",[_("strong",[v._v("匿名内部类")])]),v._v(" "),_("p",[v._v("没有名字的内部类 -\n任意一个接口都可以创建匿名内部类；任何一个非final修饰的类也可以定义匿名内部类形式")]),v._v(" "),_("p",[v._v("扩展：在Java中，支持在接口中定义类，并且支持在类中定义接口以及在接口中定义接口\n--- 内部接口默认是使用static修饰，接口中定义的类默认也是使用static修饰")]),v._v(" "),_("h3",{attrs:{id:"lambda表达式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式"}},[v._v("#")]),v._v(" Lambda表达式")]),v._v(" "),_("p",[v._v("从JDK1.8出现，函数式编程的思想")]),v._v(" "),_("p",[v._v("特点：在创建"),_("strong",[v._v("接口")]),v._v("对象的时候，用于重写接口中的"),_("strong",[v._v("唯一")]),v._v("的抽象方法")]),v._v(" "),_("p",[v._v("格式：(参数) ->{代码块}; 或者 (参数) -> 表达式;")]),v._v(" "),_("h2",{attrs:{id:"包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包"}},[v._v("#")]),v._v(" 包")]),v._v(" "),_("p",[v._v("在Java中，用package声明包 - 区分同名类，进行不同模块的划分")]),v._v(" "),_("p",[v._v("import 导包语句 - 指定要使用的类的位置")]),v._v(" "),_("p",[v._v("java.* - Java原生提供的包")]),v._v(" "),_("p",[v._v("javax.* - 后续对Java的扩展包")]),v._v(" "),_("p",[v._v("org.* - 第三方厂商提供的包")]),v._v(" "),_("p",[v._v("java.lang - 基本包/核心包 -\n这个包中的所有的类在运行的时候就已经加载到内存中了，所以在使用的时候不用导包")]),v._v(" "),_("p",[v._v("java.util - 工具包")]),v._v(" "),_("p",[v._v("java.applet - GUI，忽略")]),v._v(" "),_("p",[v._v("java.swing - GUI，忽略")]),v._v(" "),_("p",[v._v("java.math - 数学运算")]),v._v(" "),_("p",[v._v("java.io - 数据传输")]),v._v(" "),_("p",[v._v("java.text - 格式化")]),v._v(" "),_("p",[v._v("java.nio - 高并发")]),v._v(" "),_("p",[v._v("java.net - 网络传输")]),v._v(" "),_("p",[v._v("java.sql - 和数据库相关的包")]),v._v(" "),_("p",[v._v("java.security - 加密解密")]),v._v(" "),_("p",[v._v("java.time - 时间 - JDK1.8出现")])])}),[],!1,null,null,null);_.default=p.exports}}]);