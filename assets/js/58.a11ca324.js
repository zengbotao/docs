(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{836:function(e,v,s){"use strict";s.r(v);var t=s(20),a=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"js-思考题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js-思考题"}},[e._v("#")]),e._v(" JS 思考题")]),e._v(" "),v("div",{staticClass:"language-! extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("思考题一：JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？\n")])])]),v("p",[e._v("首先这几道题目想必很多人都能够很好的答出来，接下来就给大家一点思路讲出与众不同的东西。")]),e._v(" "),v("p",[v("strong",[e._v("思路引导：")])]),e._v(" "),v("ol",[v("li",[e._v("对于原始类型来说，你可以指出 "),v("code",[e._v("null")]),e._v(" 和 "),v("code",[e._v("number")]),e._v(" 存在的一些问题。对于对象类型来说，你可以从垃圾回收的角度去切入，也可以说一下对象类型存在深浅拷贝的问题。")]),e._v(" "),v("li",[e._v("对于判断类型来说，你可以去对比一下 "),v("code",[e._v("typeof")]),e._v(" 和 "),v("code",[e._v("instanceof")]),e._v(" 之间的区别，也可以指出 "),v("code",[e._v("instanceof")]),e._v(" 判断类型也不是完全准确的。")])]),e._v(" "),v("p",[e._v("以上就是这道题目的回答思路，当然不是说让大家完全按照这个思路去答题，而是存在一个意识，当回答面试题的时候，尽量去引申出这个知识点的某些坑或者与这个知识点相关联的东西。")]),e._v(" "),v("div",{staticClass:"language-! extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("思考题二：你理解的原型是什么？\n")])])]),v("p",[v("strong",[e._v("思路引导：")])]),e._v(" "),v("p",[e._v("起码说出原型小节中的总结内容，然后还可以指出一些小点，比如并不是所有函数都有 "),v("code",[e._v("prototype")]),e._v(" 属性，然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 "),v("code",[e._v("class")]),e._v(" 实现继承。")]),e._v(" "),v("div",{staticClass:"language-! extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("思考题三：bind、call 和 apply 各自有什么区别？\n")])])]),v("p",[v("strong",[e._v("思路引导：")])]),e._v(" "),v("p",[e._v("首先肯定是说出三者的不同，如果自己实现过其中的函数，可以尝试说出自己的思路。然后可以聊一聊 "),v("code",[e._v("this")]),e._v(" 的内容，有几种规则判断 "),v("code",[e._v("this")]),e._v(" 到底是什么，"),v("code",[e._v("this")]),e._v(" 规则会涉及到 "),v("code",[e._v("new")]),e._v("，那么最后可以说下自己对于 "),v("code",[e._v("new")]),e._v(" 的理解。")]),e._v(" "),v("div",{staticClass:"language-! extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("思考题四：ES6 中有使用过什么？\n")])])]),v("p",[v("strong",[e._v("思路引导：")])]),e._v(" "),v("p",[e._v("这边可说的实在太多，你可以列举 1 - 2 个点。比如说说 "),v("code",[e._v("class")]),e._v("，那么 "),v("code",[e._v("class")]),e._v(" 又可以拉回到原型的问题；可以说说 "),v("code",[e._v("promise")]),e._v("，那么线就被拉到了异步的内容；可以说说 "),v("code",[e._v("proxy")]),e._v("，那么如果你使用过 Vue 这个框架，就可以谈谈响应式原理的内容；同样也可以说说 "),v("code",[e._v("let")]),e._v(" 这些声明变量的语法，那么就可以谈及与 "),v("code",[e._v("var")]),e._v(" 的不同，说到提升这块的内容。")]),e._v(" "),v("div",{staticClass:"language-! extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("思考题五：JS 是如何运行的？\n")])])]),v("p",[v("strong",[e._v("思路引导：")])]),e._v(" "),v("p",[e._v("这其实是很大的一块内容。你可以先说 JS 是单线程运行的，这里就可以说说你理解的线程和进程的区别。然后讲到执行栈，接下来的内容就是涉及 Eventloop 了，微任务和宏任务的区别，哪些是微任务，哪些又是宏任务，还可以谈及浏览器和 Node 中的 Eventloop 的不同，最后还可以聊一聊 JS 中的垃圾回收。")])])}),[],!1,null,null,null);v.default=a.exports}}]);