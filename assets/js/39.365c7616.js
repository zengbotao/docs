(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{810:function(v,_,p){"use strict";p.r(_);var l=p(20),a=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("线程：")]),v._v(" "),_("p",[v._v("a.  当前计算机在执行的任务称之为进程")]),v._v(" "),_("p",[v._v("b.  进程中在执行的小任务称之为线程")]),v._v(" "),_("p",[v._v("c.  多线程的意义：提高CPU的利用率")]),v._v(" "),_("p",[v._v("d.  定义方式：继承Thread，实现Runnable，实现Callable接口")]),v._v(" "),_("p",[v._v("e.  多线程的并发安全问题：线程之间是相互抢占资源，而且抢占是发生在线程执行的每一步。由于线程抢占导致出现了不合理数据的现象")]),v._v(" "),_("p",[v._v("f.  同步锁机制：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("i.  利用synchronized代码块将需要保护的代码加锁\n\nii. 锁对象要求被所有的线程都认识 -\n    > 共享资源、方法区中的资源、this\n\niii. 同步和异步：同步一定是安全的，不安全一定是异步的\n\niv. 当形成锁的相互嵌套的时候，容易出现死锁\n")])])]),_("p",[v._v("g.  等待唤醒机制：必须结合锁来使用，往往需要标记位来进行状态的标记")]),v._v(" "),_("p",[v._v("h.  线程的优先级：1-10。数字越大优先级越高")]),v._v(" "),_("p",[v._v("i.  线程的状态：创建、阻塞、就绪、运行、消亡")]),v._v(" "),_("p",[v._v("j.  守护线程：被守护线程结束就会导致守护线程结束")]),v._v(" "),_("p",[v._v("k.  线程的创建场景：系统自启、用户请求、线程唤醒")]),v._v(" "),_("p",[v._v("l.  线程的销毁场景：自然，他杀，意外")]),v._v(" "),_("p",[v._v("m.  sleep和wait的区别")])]),v._v(" "),_("li",[_("p",[v._v("单例模式")]),v._v(" "),_("p",[v._v("a.  在全局过程中只存在一个实例")]),v._v(" "),_("p",[v._v("b.  特点：构造方法私有，提供本类的静态对象")]),v._v(" "),_("p",[v._v("c.  饿汉式和懒汉式")])])]),v._v(" "),_("h2",{attrs:{id:"网络编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络编程"}},[v._v("#")]),v._v(" 网络编程")]),v._v(" "),_("p",[v._v("一、网络基本概念")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("网络模型：物理层、数据链路层、网络层、传输层（UDP、TCP）、会话层、表示层\n、应用层--- http、ftp、pop3、SMATP...")])]),v._v(" "),_("li",[_("p",[v._v("网络协议：服务商和浏览器厂商之间约定的解析方式")])]),v._v(" "),_("li",[_("p",[v._v("IP地址：实际上是在网络中标记主机")]),v._v(" "),_("p",[v._v("a.  IPv4：用四组数字来表示一个IP地址，每一组数字的取值范围是0~\n> 255，一共能表示232个取值")]),v._v(" "),_("p",[v._v("b.  IPv6：表现形式比较多样")])]),v._v(" "),_("li",[_("p",[v._v("域名：厂商提供的便于记忆的字符串")]),v._v(" "),_("p",[v._v("a.  一级域名：用于表示网站的性质")]),v._v(" "),_("p",[v._v("b.  二级域名：往往是公司的名称/标记")]),v._v(" "),_("p",[v._v("c.  三级域名：表示具体的应用")])]),v._v(" "),_("li",[_("p",[v._v("DNS服务器：将域名和IP地址进行映射")])]),v._v(" "),_("li",[_("p",[v._v("端口：计算机和外界进行信息交互的媒介。端口号：0~65535，其中0~\n1024中的部分端口被计算机内部占用的")])])]),v._v(" "),_("p",[v._v("二、SocketAddress")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("用于指定地址和端口号")])]),v._v(" "),_("li",[_("p",[v._v("本身是一个抽象类，所以使用的是其子类InetSocketAddress")])]),v._v(" "),_("li",[_("p",[v._v("127.0.0.1/localhost表示本地地址")])])]),v._v(" "),_("p",[v._v("三、UDP")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("特点：")]),v._v(" "),_("p",[v._v("a.  实际上是基于网络进行数据传输的流")]),v._v(" "),_("p",[v._v("b.  不建立连接的")]),v._v(" "),_("p",[v._v("c.  不可靠，可能会产生数据的丢失")]),v._v(" "),_("p",[v._v("d.  对数据进行封包，每一个包不超过64K")]),v._v(" "),_("p",[v._v("e.  传输速度相对较快")]),v._v(" "),_("p",[v._v("f.  适用于要求速度但对可靠性依赖较低的场景：视频聊天")])]),v._v(" "),_("li",[_("p",[v._v("发送端：")]),v._v(" "),_("p",[v._v("a.  创建UDP对象")]),v._v(" "),_("p",[v._v("b.  准备数据包，将数据以及地址放到数据包中")]),v._v(" "),_("p",[v._v("c.  发送数据包")]),v._v(" "),_("p",[v._v("d.  关流")])]),v._v(" "),_("li",[_("p",[v._v("接收端：")]),v._v(" "),_("p",[v._v("a.  创建UDP对象，绑定监听的端口号")]),v._v(" "),_("p",[v._v("b.  准备数据包")]),v._v(" "),_("p",[v._v("c.  接收数据包")]),v._v(" "),_("p",[v._v("d.  关流")]),v._v(" "),_("p",[v._v("e.  解析数据")])]),v._v(" "),_("li",[_("p",[v._v("先启动接收端再启动发送端")])]),v._v(" "),_("li",[_("p",[v._v("练习：利用多线程来实现收发效果 ---\n定义一个线程做接收端，定义一个线程做发送端")])]),v._v(" "),_("li",[_("p",[v._v("255.255.255.255：广播地址。只要在同一个局域网内那么都会收到数据")])])]),v._v(" "),_("p",[v._v("四、TCP")]),v._v(" "),_("ol",[_("li",[v._v("特点：")])]),v._v(" "),_("p",[v._v("a.  基于网络进行数据传输的流")]),v._v(" "),_("p",[v._v("b.  需要建立连接的，经历三次握手")]),v._v(" "),_("p",[v._v("c.  可靠，保证数据是不会丢失的")]),v._v(" "),_("p",[v._v("d.  理论上不限制数据大小")]),v._v(" "),_("p",[v._v("e.  传输速度相对较慢")]),v._v(" "),_("p",[v._v("f.  适用于要求可靠性但是对速度依赖性相对较低的场景：文件的上传/下载")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[v._v("客户端：")]),v._v(" "),_("p",[v._v("a.  创建客户端Socket对象")]),v._v(" "),_("p",[v._v("b.  发起连接，绑定要连接的地址和端口号")]),v._v(" "),_("p",[v._v("c.  获取输出流，来写出数据，关闭输出流")]),v._v(" "),_("p",[v._v("d.  关流")])]),v._v(" "),_("li",[_("p",[v._v("服务器端：")]),v._v(" "),_("p",[v._v("a.  创建服务器端ServerSocket对象")]),v._v(" "),_("p",[v._v("b.  接受连接，获取到连接过来的Socket对象")]),v._v(" "),_("p",[v._v("c.  获取输入流，读取数据，关闭输入流")]),v._v(" "),_("p",[v._v("d.  关流")])])]),v._v(" "),_("p",[v._v("扩展：Java中的流")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("BIO - Blocking IO - 同步式阻塞式IO")])]),v._v(" "),_("li",[_("p",[v._v("NIO - NonBlocking IO - 同步式非阻塞式IO - JDK1.4")])]),v._v(" "),_("li",[_("p",[v._v("AIO - Asynchronous IO - 异步式非阻塞式IO - JDK1.8")])])]),v._v(" "),_("h1",{attrs:{id:"反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),_("blockquote",[_("p",[v._v("一、概述")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("反射是一个动态加载类的过程，在加载过程中需要解析类，然后分析类的字节码，根据字节码来产生实例对象")])]),v._v(" "),_("li",[_("p",[v._v("每一个类编译完成之后对应了一个class文件，class文件加载到内存中对应了一段字节码，如果将字节码看做对象，那么意味着可以抽取出一个代\n表字节码的类 - Class")])]),v._v(" "),_("li",[_("p",[v._v("Package - 代表包的类")])]),v._v(" "),_("li",[_("p",[v._v("Method - 代表方法的类")])]),v._v(" "),_("li",[_("p",[v._v("Field - 代表属性的类")])]),v._v(" "),_("li",[_("p",[v._v("Constructor - 代表构造方法的类")])]),v._v(" "),_("li",[_("p",[v._v("Annotation - 代表注解的类")])])]),v._v(" "),_("blockquote",[_("p",[v._v("二、获取Class对象")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("通过类名.class的方式获取指定类的字节码对象")])]),v._v(" "),_("li",[_("p",[v._v("通过对象.getClass()的方式来获取实际类型对应的字节码对象")])]),v._v(" "),_("li",[_("p",[v._v("通过Class.forName(类的全路径名)来获取指定类的字节码对象")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);