(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{798:function(t,v,_){"use strict";_.r(v);var a=_(20),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),v("h3",{attrs:{id:"面向对象和棉线过程的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和棉线过程的比较"}},[t._v("#")]),t._v(" 面向对象和棉线过程的比较")]),t._v(" "),v("p",[t._v("面向对象相对于面向过程而言的")]),t._v(" "),v("p",[t._v("无论是面向对象还是面向过程，都是一种思维方式")]),t._v(" "),v("p",[t._v("面向过程：注重流程中的每一个步骤 --- 自己动手")]),t._v(" "),v("p",[t._v("面向对象：注重对象的寻找，只要找到了这个对象，这个对象就会去完成需求\n--- 找别人代替")]),t._v(" "),v("p",[t._v("面向对象是能够完成分工合作")]),t._v(" "),v("p",[v("img",{attrs:{src:"media/image1.png",alt:""}}),t._v('{width="5.129861111111111in"\nheight="2.5506944444444444in"}')]),t._v(" "),v("p",[t._v("面向对象是优于面向过程吗？ --- 不一定 ---\n如果是相对简单的事务，面向过程相对效率较高；如果是相对复杂的事务，建议使用面向对象")]),t._v(" "),v("p",[t._v("面向对象本身是基于面向过程的")]),t._v(" "),v("h3",{attrs:{id:"类和对象的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类和对象的关系"}},[t._v("#")]),t._v(" 类和对象的关系")]),t._v(" "),v("p",[t._v("对一类事务/对象进行总结和抽取，将特征抽取为属性，将行为概括为方法，就可以用一个类来表示这一类事务/对象\n--- 类是对象的总结/提取/概括")]),t._v(" "),v("p",[t._v("利用new关键字去创建对象，然后可以对象进行属性的赋值或者是调用方法 ---\n对象是类的具体化/实例化")]),t._v(" "),v("h3",{attrs:{id:"对象的存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象的存储"}},[t._v("#")]),t._v(" 对象的存储")]),t._v(" "),v("p",[v("img",{attrs:{src:"media/image2.png",alt:""}}),t._v('{width="5.309027777777778in" height="2.28125in"}')]),t._v(" "),v("p",[v("img",{attrs:{src:"media/image3.png",alt:""}}),t._v('{width="5.429861111111111in"\nheight="2.438888888888889in"}')]),t._v(" "),v("p",[v("img",{attrs:{src:"media/image4.png",alt:""}}),t._v('{width="5.413194444444445in"\nheight="2.4680555555555554in"}')]),t._v(" "),v("h3",{attrs:{id:"成员变量和局部变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#成员变量和局部变量"}},[t._v("#")]),t._v(" 成员变量和局部变量")]),t._v(" "),v("p",[t._v("成员变量：定义在类中的变量")]),t._v(" "),v("p",[t._v("局部变量：定义在方法中的变量")]),t._v(" "),v("p",[t._v("成员变量和局部变量的区别：")]),t._v(" "),v("hr"),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("                      成员变量                                         局部变量\n")])])]),v("p",[t._v("定义位置                定义在类中                                       定义在方法/代码块中")]),t._v(" "),v("p",[t._v("存储位置                存储在堆内存中，并且在堆内存中会自动赋予默认值   存储在栈内存中")]),t._v(" "),v("p",[t._v("生命周期                在对象创建的时候产生，在对象被回收的释放         在方法执行的时候产生，方法执行完成之后，局部变量就随着方法一起移除出栈内存")]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"构造方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构造方法"}},[t._v("#")]),t._v(" 构造方法")]),t._v(" "),v("p",[t._v("特点：与类同名，没有返回值类型")]),t._v(" "),v("p",[t._v("作用：用于创建对象")]),t._v(" "),v("p",[t._v("如果一个类中没有手动定义构造方法，那么类在编译的时候会自动添加一个无参构造；如果手动定义了构造方法，那么在编译的时候就不再添加")]),t._v(" "),v("p",[t._v("构造方法可以重载")]),t._v(" "),v("h3",{attrs:{id:"this关键字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this关键字"}},[t._v("#")]),t._v(" this关键字")]),t._v(" "),v("p",[t._v("this用在类里面，代表当前在活动的对象，可以认为是一个虚拟对象")]),t._v(" "),v("p",[t._v("通过this在本类中调用本类的属性或者是方法")]),t._v(" "),v("p",[t._v("在类外，通过对象来调用方法或者是属性；那么在类内就以this代替")]),t._v(" "),v("p",[t._v("this语句 ---\n表示调用本类中对应形式的构造方法。this语句必须在当前构造方法的首行")]),t._v(" "),v("h3",{attrs:{id:"代码块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[t._v("#")]),t._v(" 代码块")]),t._v(" "),v("p",[v("strong",[t._v("初始化代码块/构造代码块")])]),t._v(" "),v("p",[t._v("在类中用{}括起来的代码 ---\n无论调用哪个构造方法，都会先于构造方法执行一次")]),t._v(" "),v("p",[v("strong",[t._v("局部代码块")])]),t._v(" "),v("p",[t._v("在方法中，用一对{}括起来的代码 ---\n限制变量的生命周期以提高栈内存的利用率")]),t._v(" "),v("h2",{attrs:{id:"面向对象的特征"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的特征"}},[t._v("#")]),t._v(" 面向对象的特征")]),t._v(" "),v("p",[t._v("封装、继承、多态、(抽象)")]),t._v(" "),v("h3",{attrs:{id:"封装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),v("p",[t._v("体现形式：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("方法 - 提高了代码的利用率")])]),t._v(" "),v("li",[v("p",[t._v("类 - 将属性和方法封装到一个逻辑块 -> 类")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("属性的私有化 -")]),t._v(" "),v("blockquote",[v("p",[t._v("将属性用private修饰避免在类外直接操作属性值，然后通过对外提供的方法（一般是get/set方法）来间接操作属性的值，这种方法有效的避免属性出现不合法的数据的场景")])])]),t._v(" "),v("li",[v("p",[t._v("内部类")])])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);