(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{801:function(v,_,l){"use strict";l.r(_);var t=l(20),p=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("前言")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("String")]),v._v(" "),_("p",[v._v("a.  空串：在内存中会创建一个长度为0的数组，本身是有地址引用的，所以可以去调用属性或者是方法")]),v._v(" "),_("p",[v._v("b.  字符串为空：字符串的值是null，实际上这个对象并不存在，因此也不能调用方法或者属性。如果利用null调用方法或者是属性，会抛出NullPointerException")]),v._v(" "),_("p",[v._v("c.  String类中提供了大量操作字符串但是不改变原字符串的方法，都是产生一个新的字符串")]),v._v(" "),_("p",[v._v("d.  因为字符串在底层是以字符数组形式来存储，所以字符串的操作往往是以字符数组的形式来操作\n> --- compareTo,concat")])])]),v._v(" "),_("blockquote",[_("p",[v._v("Regex")])]),v._v(" "),_("blockquote",[_("p",[v._v("一、概述")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("针对字符串来提供范围性的校验")])]),v._v(" "),_("li",[_("p",[v._v("正则表达式所对应的类Pattern，所有的正则形式都是在这个类")])]),v._v(" "),_("li",[_("p",[v._v("[a-z] - 任意一个小写字母")])]),v._v(" "),_("li",[_("p",[v._v("[^a-z] - 除了小写字母")])]),v._v(" "),_("li",[_("p",[v._v("预定义字符：. \\w \\d \\s \\W \\D \\S 6. 数量词：+ * ? {n} {n,}\n{n,m}")])])]),v._v(" "),_("div",{staticClass:"language-{=html} extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("\x3c!-- --\x3e\n")])])]),_("ol",{attrs:{start:"7"}},[_("li",[_("p",[v._v("^如果放在[]中，表示非；如果^放在了整个表达式的开头，表示强制以当前字符开头")])]),v._v(" "),_("li",[_("p",[v._v("只需要掌握基本正则，能看懂基本正则即可 --- 常用的20个正则 ---")]),v._v(" "),_("blockquote",[_("p",[v._v("正则生成器")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("二、捕获组")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("用()括起来的单元称之为捕获组")])]),v._v(" "),_("li",[_("p",[v._v("在正则表达式中，会对捕获组进行自动的编号，编号从1开始")])]),v._v(" "),_("li",[_("p",[v._v("\\n引用编号为n的捕获组")])]),v._v(" "),_("li",[_("p",[v._v("捕获组的编号是从 ( 的出现位置开始依次计数")])])]),v._v(" "),_("h1",{attrs:{id:"包装类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类"}},[v._v("#")]),v._v(" 包装类")]),v._v(" "),_("p",[v._v("一、概述")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("因为基本类型的变量身上没有任何的方法和属性，所以针对基本类型提供了对应的类形式")]),v._v(" "),_("blockquote",[_("p",[v._v("--- 包装类")])])]),v._v(" "),_("li",[_("p",[v._v("利用这个类产生对象，调用对象身上的方法来操作这个数据")])])]),v._v(" "),_("p",[v._v("三、注意问题")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("除了int和char以外，其他类型的包装类都是将首字母大写")])]),v._v(" "),_("li",[_("p",[v._v("自动封箱：将基本类型的变量直接赋值给对应的引用类型的对象。自动封箱在底层调用的是对应类的valueOf方法")])]),v._v(" "),_("li",[_("p",[v._v("对于"),_("strong",[v._v("整数")]),v._v("而言，在进行自动封箱的时候会有范围判断："),_("strong",[v._v("-128~127")]),v._v("，当在这个范围内的时候，会从同一个数组的同一个位置去取值，那么此时判断的结果应该是相等")])]),v._v(" "),_("li",[_("p",[v._v("自动拆箱：将引用/包装类型的对象直接赋值给对应的基本类型的变量。自动拆箱在底层调用的是对应对象身上的***Value方法")])]),v._v(" "),_("li",[_("p",[v._v("自动封箱/拆箱是JDK1.5的特性之一")])]),v._v(" "),_("li",[_("p",[v._v("包装类产生的对象，只要实际值一样，那么哈希码一定一样")])]),v._v(" "),_("li",[_("p",[v._v("NaN和任何东西都不相等，包括自己本身")])])]),v._v(" "),_("h1",{attrs:{id:"数学类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数学类"}},[v._v("#")]),v._v(" 数学类")]),v._v(" "),_("p",[v._v("一、概述")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("用于提供基本/初等数学运算的类，包含指数、对数、幂函数、三角函数等")])]),v._v(" "),_("li",[_("p",[v._v("针对基本类型来进行运算")])]),v._v(" "),_("li",[_("p",[v._v("BigDecimal：用于进行精确计算小数的类。在计算的时候要求小数以字符串形式传入，在底层会进行逐位计算")])])])])}),[],!1,null,null,null);_.default=p.exports}}]);